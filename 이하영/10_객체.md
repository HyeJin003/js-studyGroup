# 객체(Object)

## 1. 객체란 무엇인가?
> 자바스크립트는 **객체 기반 언어**로, **원시 타입(Primitive)** 을 제외한 대부분의 값(함수, 배열, 정규 표현식 등)은 **객체**입니다.  
> 객체는 **"키(Key)와 값(value)" 쌍으로 이루어진 데이터 집합**으로, 이 쌍을 **프로퍼티(Property)** 라고 합니다.  
> 값에는 숫자, 문자열, 함수 등 **모든 자료형**이 올 수 있으며, **프로퍼티의 값이 함수**일 경우 **메서드(Method)** 라고 합니다.

### 🍀 프로퍼티(Properties)
> 객체의 **속성(데이터)** 을 저장하는 요소로, **`"키: 값"`** 형태로 **쌍을 이룬 데이터 집합**입니다.

- 키는 보통 문자열이며, 값에는 **모든 자료형**이 올 수 있습니다.
- **점 표기법** 또는 **대괄호 표기법**으로 접근할 수 있습니다.


### 🍀 메서드(Methods)
> 객체의 **프로퍼티 값이 함수**인 것을 메서드라고 합니다.

- 객체가 수행할 동작을 정의합니다.
- **`this`** 키워드를 통해 **객체 자신에 접근**할 수 있습니다.

## 2. 객체 생성 방법
> JavaScript에서 객체를 생성하는 방법은 다양하지만, **대표적으로 다음 세 가지**가 있습니다.

### 🍀 객체 리터럴(JSON 형태)
> **가장 간단하고 많이 쓰이는 방법**으로, 중괄호 **`{}`** 를 사용해 **객체를 생성**합니다.

```js
// 객체 리터럴(JSON)을 사용한 점 표기법
let user1 = { name: "이하영", age: 25, hobby: "게임" };                  // 객체 리터럴(JSON)로 객체 생성

// 점 표기법 접근
console.log(user1.name, user1.age, user1.hobby);                        // 이하영 25 게임
console.log(typeof user1, user1);                                       // 결과: object { name: '이하영', age: 25, hobby: '게임' }

// 객체 리터럴(JSON)을 사용한 대괄호 표기법
let user2 = { ["name"]: "이하영", ["age"]: 25, ["hobby"]: "게임" };      // 객체 리터럴(JSON)로 객체 생성

// 대괄호 표기법 접근
console.log(user2["name"], user2["age"], user2["hobby"]);               // 이하영 25 게임
console.log(typeof user2, user2);                                       // 결과: object { name: '이하영', age: 25, hobby: '게임' }
```

### 🍀 Object() 객체 생성자 
> JavaScript의 기본 내장 생성자인 **`Object`** 를 사용해서 **객체를 생성**하는 방법입니다.

```js
// Object() 객체 생성자를 사용한 점 표기법
let user1 = new Object();                                     // object 생성자 함수로 user1 객체 생성

user1.name = "이하영";                                        // user1 객체에 name 프로퍼티 추가
user1.age = 25;                                              // user1 객체에 age 프로퍼티 추가
user1.hobby = "게임";                                        // user1 객체에 hobby 프로퍼티 추가

// 점 표기법 접근
console.log(user1.name, user1.age, user1.hobby);             // 출력: 이하영 25 게임
console.log(typeof user1, user1);                            // 출력: object { name: '이하영', age: 25, hobby: '게임' }

// Object() 객체 생성자를 사용한 대괄호 표기법
let user2 = new Object();                                    // object 생성자 함수로 user2 객체 생성

// 대괄호 표기법 접근
user2["name"] = "이하영";                                     // user2 객체에 name 프로퍼티 추가
user2["age"] = 25;                                           // user2 객체에 age 프로퍼티 추가
user2["hobby"] = "게임";                                     // user2 객체에 hobby 프로퍼티 추가

console.log(user2["name"], user2["age"], user2["hobby"]);    // 이하영 25 게임
console.log(typeof user2, user2);                            // 출력: object { name: '이하영', age: 25, hobby: '게임' }
```

### 🍀 생성자 함수
> 함수를 통해 객체를 생성하고, **`new`** 키워드로 인스턴스를 만들며, 다른 함수들과 달리 **대문자**로 시작합니다.

```js
// 생성자 함수
function User(name, age, hobby) {                // 관례상 생성자 함수 이름의 첫 글자를 대문자로 작성
  // 각 속성(name, age, hobby)에 전달받은 값을 저장합니다.
  this.name = name;                              // name 프로퍼티를 새 객체(this)에 추가
  this.age = age;                                // age 프로퍼티를 새 객체(this)에 추가
  this.hobby = hobby;                            // hobby 프로퍼티를 새 객체(this)에 추가

  // 생성된 객체에 메서드를 직접 추가(생성된 객체마다 자기만의 introduce 메서드를 가지게 됨)
  // 따라서 user2, user3 등의 객체를 생성했을 경우 user2.introduce(); user3.introduce(); 과 같이 재사용이 가능하다.
  // 하지만 이 방식은 객체가 많아질 수록 introduce 메서드가 매번 복사되기 때문에 메모리 효율이 떨어집니다.
  this.introduce = function() {
    console.log("이름: " + this.name + " 나이: " + this.age + "살" + " 취미: " + this.hobby);
  };
}

let user1 = new User("하영", 25, "게임");         // user1 객체 생성(name, age, hobby)
let user2 = new User("영하", 52, "운동");         // user2 객체 생성(name, age, hobby)

console.log(user1);                              // 출력: User { name: '하영', age: 25, hobby: '게임' }
console.log(user2);                              // 출력: User { name: '영하', age: 52, hobby: '운동' }

user1.introduce();                               // 출력: 이름: 하영 나이: 25살 취미: 게임
user2.introduce();                               // 출력: 이름: 영하 나이: 52살 취미: 운동
```

## 3. 객체 프로퍼티 접근

### 🍀 프로퍼티란?
> 객체는 **"키(key)와 값(value)"의 쌍**으로 구성되어 있고, 이를 **프로퍼티**라고 부릅니다.
- 키는 **문자열** 또는 **Symbol**만 가능하며, 값을 저장하기 위한 이름입니다.
- 값은 **모든 자료형**이 올 수 있고, **함수일 경우 메서드(method)** 라고 부릅니다.

```js
let user = {
  name: "하영",              // 문자열 키
  age: 25,                  // 숫자 값
  introduce: function() {   // 메서드(값이 함수)
    console.log("안녕하세요!");
  }
};
```

### 🍀 프로퍼티 키
> 프로퍼티의 키는 기본적으로 **문자열**로 처리됩니다. 다른 자료형이 들어와도 **자동으로 문자열로 변환**됩니다.

#### ✅ 유효한 키 이름이라면 따옴표 생략이 가능합니다.
```js
let user = {
  name: "하영",    // 유효한 키
  age: 25         // 유효한 키
};
```

#### ❌ 유효하지 않은 키 이름일 경우 따옴표 필수
```js
let user = {
  "first-name": "하영",  // 하이픈(-)이 포함된 경우 따옴표 필수
  1: 10,                 // 숫자 키는 내부적으로 "1"로 처리
  "function": 1          // 예약어도 사용 가능하지만 권장하지 않
};
```

### 🍀 프로퍼티 접근
> JavaScript 객체의 프로퍼티(키-값 쌍)에 접근하는 방법은 **대표적으로 두 가지**가 있습니다.

#### 📍 점 `.` 표기법
> 키가 **유효한 식별자(이름)** 인 경우 사용 가능

```js
// 객체 리터럴(JSON)을 사용한 점 표기법
let user = { name: "이하영", age: 25, hobby: "게임" };                 // 객체 리터럴(JSON)로 객체 생성

// 점 표기법 접근
console.log(user.name, user.age, user.hobby);                         // 이하영 25 게임
console.log(typeof user, user);                                       // 결과: object { name: '이하영', age: 25, hobby: '게임' }
```
#### 📌 점 표기법 사용 조건
- 프로퍼티 이름(키)이 **유효한 식별자일 때**만 점 **`.`** 표기법을 사용할 수 있습니다.
  - 유효한 식별자 조건
    - 문자(**`a~z`**, **`A~Z`**), 밑줄 **`_`** 또는 달러 기호 **`$`** 로 시작해야 합니다.
    - **숫자는 중간 또는 끝**에는 올 수 있지만, **숫자로 시작할 수는 없습니다.**
    - 공백(**`" "`**), 하이픈(**`-`**), 특수문자(**`!`** **`,`** **`@`** 등)는 **포함할 수 없습니다.**
    - 예약어(**`class`**, **`function`** 등)는 사용이 가능하지만, **권장하지 않습니다.**

- ✅ **점 표기법 사용이 가능한 예시**
  - **`name`** **`userName`** **`_id`** **`$token`** **`age1`**

- ❌ **점 표기법 사용이 불가능한 예시**
  - **`1name`** **`first-name`** **`user name`** **`my@key`**
  - **`function`** **`default`** **123**

#### 🌜🌛 대괄호 `[]` 표기법
> 키가 **문자열 표현식**이거나 **유효한 이름이 아닐 때** 사용

```js
// 객체 리터럴(JSON)을 사용한 대괄호 표기법
let user = { ["name"]: "이하영", ["age"]: 25, ["hobby"]: "게임" };      // 객체 리터럴(JSON)로 객체 생성

// 대괄호 표기법 접근
console.log(user["name"], user["age"], user["hobby"]);                 // 이하영 25 게임
console.log(typeof user, user);                                        // 결과: object { name: '이하영', age: 25, hobby: '게임' }
```
#### 📌 대괄호 표기법 사용 조건
- 대괄호 표기법에서는 **사용이 불가능한 프로퍼티 이름(키)가 거의 없습니다.**
  - 프로퍼티 이름(키) 공백, 하이픈(-), 숫자, 특수문자 등 **식별자로 쓸 수 없는 문자열이 포함된 경우**
  - 프로퍼티 이름(키)이 변수나 표현식으로 **동적으로 결정되는 경우**
  - 점 표기법과 마찬가지로 예약어(**`function`** **`class`** 등)일 경우 **사용은 가능하지만, 권장하지 않습니다.**
- 프로퍼티 이름(키)가 **반드시 문자열**이어야 하며, 만약 숫자나 다른 자료형이라도 **내부적으로 문자열로 변환**됩니다.

- ❌ **대괄호 표기법 사용이 불가능한 예시**

```js
let obj = {};

console.log(obj[undefined]);  // undefined (프로퍼티 이름(키) 'undefined'로 변환됨)
console.log(obj[null]);       // undefined (프로퍼티 이름(키) 'null'로 변환됨)
console.log(obj[123]);        // undefined (프로퍼티 이름(키) '123'으로 변환됨)
console.log(obj[{a:1}]);      // undefined (프로퍼티 이름(키) '[object Object]'로 변환됨)

// undefined, null, 객체 등을 키로 사용하면 자동으로 문자열로 변환되기 때문에, 의도한 결과를 얻지 못할 수 있습니다.
// 예를 들어, undefined는 "undefined", null은 "null"로 변환되며, 객체는 "[object Object]"로 변환됩니다.
```

#### ❓ 예약어란?
> 프로그래밍 언어의 **문법 자체를 구성하는 단어**로, 이미 특정한 기능이나 목적을 위해 **언어 내부에서 예약 되어 있는 단어**입니다.  
> 예시: **`function`** **`return`** **`var`** 등

#### 👉 예약어로 변수를 선언한 경우

```js
let function = 5;  //SyntaxError: Unexpected token 'function'
```
- 자바스크립트는 이미 **`function`** 이 **함수를 선언하는 키워드**라는 걸 알고 있기 때문에,
- 개발자가 다른 의미로 쓰려고 하면 **문법 오류(SyntaxError)** 를 발생시킵니다.

#### 👉 예약어 객체의 키로 사용 경우

```js
let obj = {
  function: "정의된 예약어지만 키로는 가능"
};

console.log(obj["function"]);  // 출력: 정의된 예약어지만 키로는 가능
```
- 이렇게 문자열로 명시하거나 대괄호 표기법을 쓰면 사용은 가능하지만, 혼동을 줄 수 있기 때문에 **권장하지 않습니다.**

#### 📌 예약어 정리
> 예약어란 **자바스크립트가 이미 의미를 부여한 단어들**이며,  
> 이러한 단어는 문법적 역할이 있기 때문에 **식별자(변수, 함수, 키 등)** 로 자유롭게 사용할 수 없습니다.

### 🍀 존재하지 않는 프로퍼티 접근
> 객체에 없는 프로퍼티에 접근하면 **`undefined`가 반환**됩니다.

```js
let person = { name: "이하영", age: 25 };    // person 객체에 name age 프로퍼티 생성

console.log(person.hobby);                  // 출력: undefined -> person 객체에는 hobby(프로퍼티)가 존재하지 않음
```

### 🍀 프로퍼티 값 갱신
> 객체에 이미 있는 프로퍼티에 **새로운 값을 할당하면 갱신**됩니다.

```js
let person = { name: "이하영", age: 25 };    // person 객체에 name age 프로퍼티 생성

person.name = "영하";
console.log(person.name);                   // 출력: "영하"
```

### 🍀 프로퍼티 동적 생성
> **없는 키에 값을 할당**하면, 새로운 프로퍼티가 **자동으로 추가**됩니다.

```js
let person = { name: "이하영", age: 25 };    // person 객체에 name age 프로퍼티 생성

person.hobby = "게임";                      // hobby(프로퍼티)는 존재하지 않음 -> 새로운 프로퍼티(hobby) 생성
console.log(person.hobby);                 // 출력: "게임"
```

### 🍀 프로퍼티 삭제
> **delete 키워드**를 사용하여 **프로퍼티를 삭제**할 수 있습니다.

```js
let person = { name: "이하영", age: 25, hobby: "게임" };    // person 객체에 name, age, hobby 프로퍼티 생성

delete person.hobby;                                       // delete 키워드를 사용하여 hobby(프로퍼티) 삭제
console.log(person.hobby);                                 // 출력: undefined
```
- **`delete person;`** 은 객체 자체를 삭제하지 않습니다.

## ⚠️ 참고용 정리본
> 아래의 **`this 키워드`** 와 **`prototype`** 은 본문에서 등장하여 소개하게 되었습니다.  
> 지금은 **이런 개념이 있구나 정도로 가볍게 읽고**, 나중에 강의 또는 스터디를 통해 학습하니 부담갖지 않아도 될 것 같습니다.

## 4. `this` 키워드란?
> **`this`** 는 **함수가 실행되는 방식**에 따라 가리키는 대상이 달라지는 특별한 키워드입니다.  
> 쉽게 말해, **지금 누가 이 함수를 호출했는가?** 에 따라 **`this`** 가 달라집니다.

### 🍀 객체 메서드에서의 `this`
> **객체의 메서드로 함수가 호출**되면, **`this`는 메서드를 호출한 객체 자신**을 가리킵니다.

```js
// 올바른 this 사용예
let user = {
  name: "하영",
  introduce: function() {
    console.log("안녕하세요, 저는 " + this.name + "입니다");
  }
};

// this는 user 객체를 가리킵니다.
user.introduce();  // 출력: 안녕하세요, 저는 하영입니다.

// 메서드를 변수에 따로 할당해서 호출하면,
// this는 더 이상 원래 객체(user2)를 가리키지 않습니다.
let user2 = {
  name: "하영",
  introduce: function() {
    console.log("안녕하세요, 저는 " + this.name + "입니다");
  }
};

let sayHi = user2.introduce;    // 메서드를 변수에 따로 저장

sayHi();  // 출력: 안녕하세요, 저는 undefined입니다.
// -> this는 더 이상 user2 객체를 가리키지 않기 때문에 undefined를 출력
// -> 이렇게 되는 이유는 "this는 함수를 어떻게 호출했느냐"에 따라 달라지기 때문입니다.
// 이 동작은 나중에 배울 "전역 객체"와 관련되어 있습니다.
```

### 🍀 생성자 함수에서의 `this`
> **`new`** 키워드로 생성자 함수를 호출하면, **`this`는 새로 만들어진 객체(instance)** 를 가리킵니다.

```js
function User(name, age) {
  // 생성자 함수 내부의 this는 새로 만들어질 객체를 가리킴
  this.name = name;                     // name 프로퍼티를 새 객체(this)에 추가
  this.age = age;                       // age 프로퍼티를 새 객체(this)에 추가

  // introduce 메서드를 객체에 직접 정의(객체마다 따로 생성됨)
  this.introduce = function() {
    console.log("저는 " + this.name + "이고, " + this.age + "살입니다.");
  };
}

// new 키워드를 사용해 User 생성자 함수로 객체 생성
let user1 = new User("하영", 25);        // 속성(하영, 25) 추가
let user2 = new User("영하", 52);        // 속성(영하, 52) 추가

// 각 객체의 introduce 메서드 실행
user1.introduce();                       // 출력: 저는 하영이고, 25살입니다.
user2.introduce();                       // 출력: 저는 영하이고, 52살입니다.

// 각 객체의 속성 확인
console.log(user1.name);                 // 출력: 하영
console.log(user2.name);                 // 출력: 영하
```

- **`this.속성 = 값;`** 구조는 **객체에 속성을 추가하고 값을 설정하는 방식**입니다.
- **`this`** 는 **어디서, 어떻게 함수가 호출되었는지**에 따라 달라지므로 항상 주의해서 사용해야 합니다.

## 5. prototype과 메서드 공유란?
> 모든 객체가 같은 동작을 해야 할 때 사용합니다.  
> 생성자 함수 내부에 메서드를 정의하면, **객체가 많아질 수록 메서드가 복사되어 메모리 사용량이 늘어나지만**,  
> 반대로 **`prototype`** 을 사용하면, **모든 객체(인스턴스)가 하나의 메서드를 공유해 메모리를 효율적으로 사용**할 수 있습니다.

```js
// 생성자 함수
function User(name, age, hobby) {                // 관례상 생성자 함수 이름의 첫 글자를 대문자로 작성
  // 생성되는 객체마다 각각의 속성(name, age, hobby)이 만들어집니다.
  this.name = name;                              // name 프로퍼티를 새 객체(this)에 추가
  this.age = age;                                // age 프로퍼티를 새 객체(this)에 추가
  this.hobby = hobby;                            // hobby 프로퍼티를 새 객체(this)에 추가
}

// prototype에 메서드를 정의하면
// -> 모든 User 객체가 이 하나의 introduce 메서드를 공유합니다.
User.prototype.introduce = function() {
    console.log("이름: " + this.name + " 나이: " + this.age + "살" + " 취미: " + this.hobby);
};

let user1 = new User("하영", 25, "게임");        // user1 객체 생성(name, age, hobby)
let user2 = new User("영하", 52, "운동");        // user2 객체 생성(name, age, hobby)

user1.introduce();                              // 출력: 이름: 하영 나이: 25살 취미: 게임
user2.introduce();                              // 출력: 이름: 영하 나이: 52살 취미: 운동
```

#### 🍀 상황별 메서드 활용

- **생성자 내부 메서드**
  - 각 객체가 **메서드를 개별적으로 다르게 동작**하도록 해야 할 때,
  - 객체마다 메서드를 **따로 수정**하거나 상태를 **다르게 유지**해야 할 때 사용됩니다.
    - 예를 들어, 특정 객체만 특별한 인사말을 하도록 다르게 구현해야 한다면 생성자 내부에 직접 추가하는 것이 적합합니다.
    - **객체가 100개**면, **메서드도 100개**가 생성됩니다.

- **prototype 메서드**
  - 모든 객체가 같은 **동작을 공유**하고, 메서드를 **한 곳에서 관리**하고 싶을 때,
  - **메모리 효율을 높이고** 코드 **유지보수를 쉽게** 하고 싶을 때 사용됩니다.
    - 예를 들어, 모든 사용자 객체가 같은 인사말을 공유하고, 나중에 인사말 방식을 한 번에 변경하고 싶다면 prototype에 메서드를 정의하는 게 효율적입니다.
    - **객체가 100개**여도, **메서드는 1개**만 생성됩니다.
