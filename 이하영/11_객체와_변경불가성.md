# 객체와 변경불가성(Immutability)

## 1. 변경불가성(Immutability)이란?
> 객체가 생성된 이후 그 **상태를 변경할 수 없는 디자인 패턴을 의미**하며, **[함수형 프로그래밍](https://itstory1592.tistory.com/120#%ED%--%A-%EC%--%--%ED%--%--%--%ED%--%--%EB%A-%-C%EA%B-%B-%EB%-E%--%EB%B-%-D%EC%-D%--%--%ED%-A%B-%EC%A-%--)의 핵심 원리** 중 하나입니다.
>   
> JavaScript에서 **객체는 참조(reference) 형태로 전달**됩니다.
> 하지만 객체가 참조를 통해 공유되어 있다면, 그 **상태가 언제든지 변경될 수 있기 때문에 문제가 발생**할 수 있습니다.  
>     
> 이러한 문제를 해결하기 위해 객체를 **불변 객체(immutable object)** 로 만들어 **프로퍼티의 직접적인 수정을 방지**합니다.  
> 상태 변경이 필요할 경우 기존 객체를 직접 수정하는 대신, **방어적 복사(defensive copy)** 를 통해 **새로운 객체를 생성한 후 변경된 값을 반영**합니다.

### 🍀 참조 형태란?
> JavaScript에서 **`객체(Object)`** **`배열(Array)`** **`함수(Function)`** 등 **비원시 타입(non-primitive type)** 은 변수에 **값 자체가 아닌 '참조(주소)'가 저장**됩니다.  
> 즉, 어떤 객체를 다른 변수에 할당하면 **객체의 복사본이 아닌, 같은 메모리 주소를 참조하는 또 다른 이름(alias)이 만들어지는 것**입니다.

```js
const obj1 = { name: "HaYeong" };    // obj1에 객체 생성
const obj2 = obj1;                   // obj2가 obj1을 참조

obj2.name = "Lee";                   // obj2를 통해 name 프로퍼티 값을 변경

console.log(obj1.name);              // 출력: "Lee" (obj1도 동일한 객체를 참조)
```
- **`obj1`** **`obj2`** 는 **동일한 객체를 참조**하고 있기 때문에, 한 쪽에서 값을 변경하면 **양쪽 모두에게 영향을 미칩니다.**

### 🍀 불변 객체(immutable object)란?
> **한 번 생성되면 내부 상태가 절대 바뀌지 않는 객체**를 의미합니다.
> 객체의 속성(property) 값을 변경하려 할 경우, **새로운 객체를 생성해서** 변경된 값을 반영하는 방식으로 사용됩니다.

```js
const user = { name : "HaYeong", age: 25 };

// user 객체의 age 값을 변경한 새로운 객체를 만들고 싶을 때
const updateUser = { ...user, age: 26 };

console.log(user.age);          // 25 (원본 객체)
console.log(updateUser.age);    // 26 (새로운 객체)
```
- 원본을 유지하면서 새로운 상태를 가진 객체를 만드는 방식은 **예측 가능한 코드 작성**과 **디버깅 용이성**에 큰 도움이 됩니다.

### 🍀 방어적 복사(defensive copy)란?
> **기존 객체를 직접 수정하지 않고, 복사본을 만든 후 해당 복사본을 수정하는 방식**을 의미합니다.  
> 이 방식은 **원본 데이터를 보호**하면서도 **변경이 필요한 상황에 유연하게 대응**할 수 있도록 도와줍니다.

- 구체적인 예제와 활용법은 **`3. 불변 데이터 패턴(Immutable data pattern)`** 에서 자세히 다룰 예정입니다.

## 2. 변경 불가능한 값(Immutable Value)과 변경 가능한 값(Mutable Value)의 구분
> JavaScript의 **데이터 타입은 크게 두 가지**로 나뉩니다.  
> - JavaScript의 데이터 타입은 기본적으로 **변경 불가능한 값(Immutable Value)** 을 가지는 **원시 타입**  
> - **변경 가능한 값(Mutable Value)** 을 가지는 **객체(비원시 타입)** 로 나뉩니다.

#### ⚠️ 헷갈릴 수 있어요!
- **`const`** 는 변수 자체의 **재할당**을 막는 것이지, 변수에 저장된 **값의 불변을 보장하지 않습니다.**
- **객체의 내부 상태(프로퍼티)는 변경 가능**합니다.

### 🍀 변경 불가능한 값(Immutable Value - 불변 값) - 원시 타입
> **`String`** **`Number`** **`Boolean`** **`null`** **`undefined`** **`Symbol`** **`BigInt`**  
> 변수에 할당된 값이 한 번 생성되면 **절대 변경될 수 없습니다.**  
> 원시 타입 변수를 수정하는 것처럼 보여도, 실제로는 **새로운 값**이 만들어지고, 변수는 **새로운 값을 참조**하게 됩니다.

```js
// 기존 문자열을 다른 문자열로 대입
let str1 = "HaYeong";
str1 = "Lee";         // "HaYeong"이 수정되는 것이 아닌 "Lee" 라는 새로운 문자열이 생성되어 str1에 재할당

console.log(str1);    // 출력: "Lee"

// 기존 문자열에 이어 붙인 형태
let str2 = "HaYeong";
str2 = str2 + " Lee";      // "HaYeong"이 수정되는 것이 아닌, "HaYeong Lee"라는 새로운 문자열이 생성되어 str2에 재할당

console.log(str2);         // 출력: "HaYeong Lee"
```

### 🍀 변경 가능한 값(Mutable Value - 가변 값) - 비원시 타입
> **`Object`** **`Array`** **`Function`**  
> 변수에 할당된 **객체의 내부 상태(프로퍼티)** 는 언제든지 **직접 변경될 수 있습니다.**  
> 객체가 **참조(Reference)** 형태로 저장되기 때문이며, 여러 변수가 하나의 객체를 참조할 때 **예기치 않은 부작용(Side Effect)** 이 발생할 수 있습니다.

```js
const user = { name: "HaYeong" };
user.name = "Lee";         // const로 선언되었지만 객체의 프로퍼티는 변경이 가능(객체 내부(프로퍼티)는 여전히 Mutable이기 때문)

console.log(user.name);    // 출력: "Lee"
```

## 3. 불변 데이터 패턴(Immutable data pattern)
> 의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 **레퍼런스를 참조한 다른 객체에서 객체를 변경**하기 때문입니다.  
> 이 문제의 해결 방법은 **객체를 불변 객체로 만들어 프로퍼티의 변경을 방지**하며,  
> 객체의 변경이 필요한 경우에는 **참조가 아닌 객체의 방어적 복사(Defensive Copy)를 통해 새로운 객체를 생성한 후 변경**합니다.

### 🍀 객체의 방어적 복사(Defensive Copy)
> **`Object.assign()`**  
> 기존 객체를 직접 수정하지 않고, **얕은 복사(Shallow Copy)** 를 통해 **새로운 객체를 만들어 변경하는 방식**입니다.

#### 📌 얕은 복사(Shallow Copy)란?
> 객체를 복사할 때 **최상위 프로퍼티만 복사**하고, 그 안에 있는 **중첩 객체나 배열은 참조값만 복사**하는 것입니다.

```js
// assign() 사용 방법
Object.assign(target, ...sources);
// target - 복사 받을 대상 객체
// ...sources - 복사할 소스 객체
```

```js
// 객체 복사(Copy)
const user = { name: "HaYeong", profile: { age: 52 } };

// Object.assign()을 사용해 얕은 복사(Shallow Copy) 수행
const copyUser = Object.assign({}, user);

// 중첩 객체(profile)는 여전히 원본(user)과 같은 참조를 공유하고 있음
copyUser.profile.age = 25;

// 따라서 profile.age를 수정하면 user.profile.age도 같이 변경됨
console.log(copyUser);             // 출력: { name: 'HaYeong', profile: { age: 25 } }

// copyUser와 user는 서로 다른 객체이므로 false 출력
console.log(user === copyUser);    // 출력: false
```

```js
// 객체 병합(Merge) - 원본 수정
const obj1 = { A: "하영" };
const obj2 = { B: "은재" };
const obj3 = { C: "홍상" };

// obj1에 obj2와 obj3의 프로퍼티가 병합됨 -> obj1이 직접 변경됨
const merge1 = Object.assign(obj1, obj2, obj3);

console.log(merge1);    // 출력: { A: '하영', B: '은재', C: '홍상' }
console.log(obj1);      // 출력: { A: '하영', B: '은재', C: '홍상' } - 병합된 결과와 동일 (원본 변경)

// 새 객체 병합(Merge) - 원본 객체는 수정되지 않음
const obj4 = { A: "은별" };
const obj5 = { B: "초롱" };
const obj6 = { C: "혜진" };

// {}를 타겟으로 사용하면 원본은 보존되고, 병합된 새 객체를 반환
const merge2 = Object.assign({}, obj4, obj5, obj6);

console.log(merge2);    // 출력: { A: '은별', B: '초롱', C: '혜진' }
console.log(obj4);      // 출력: { A: '은별' } - 원본 유지
```

```js
// assign() 얕은 복사(Shallow Copy) 예시
const user = { name: "Lee", address: { city: "Gyeonggi-do" } };

// 새로운 빈 객체에 Object.assign을 사용해 얕은 복사(Shallow Copy)
const copyUser = Object.assign({}, user);

// copyUser와 user는 서로 다른 객체이므로 false 출력
console.log(user === copyUser);                    // 출력: false

// name 프로퍼티는 완전히 분리되어 있으므로 분리되어 동작
copyUser.name = "HaYeong";
console.log(user.name);                            // 출력: 'Lee'
console.log(copyUser.name);                        // 출력: 'HaYeong'

// 중첩 객체는 얕은 복사(Shallow Copy)로 인해 같은 객체를 참조
console.log(user.address === copyUser.address);    // 출력: true

// 중첩 객체를 변경하면 서로 영향을 줌
user.address.city = "Seoul";
console.log(copyUser.address.city);                // 출력: 'Seoul'
```

### 🍀 불변 객체화를 통한 객체 변경 방지
> **`Object.freeze()`**  
> 객체를 **동결(freeze)** 시켜서 **프로퍼티의 추가, 삭제, 수정을 모두 막아 불변 객체처럼 만드는 방법**입니다.

```js
// freeze() 사용 방법
Object.freeze(obj);    // 객체 obj를 동결시켜 프로퍼티 추가, 삭제, 수정이 불가능(불변)하게 만듦
```

```js
// freeze() 활용 예시
const user = { name: "Lee", profile: { age: 52 } };
console.log(user.name);                // 출력: "Lee"

// freeze() 적용 전 상태 확인
console.log(Object.isFrozen(user));    // 출력: flase

// freeze() 적용
Object.freeze(user);

// freeze() 적용 후 상태 확인
console.log(Object.isFrozen(user));    // 출력: true

// 프로퍼티 변경 시도 (무시됨)
user.name = "HaYeong";
console.log(user.name);                // 출력: "Lee"

// 중첩 객체는 여전히 변경 가능
user.profile.age = 25;
console.log(user.profile.age);         // 출력: "25"

console.log(user);                     // 출력: { name: "Lee", profile: { age: 25 } }
```

#### ❄️ 깊은 동결 `Deep Freeze()` 란?
> **`Object.freeze()`** 는 **최상위 프로퍼티까지만 동결**하며, **중첩된 객체**는 여전히 변경이 가능합니다.  
>   
> **`deepFreeze()`** 는 이러한 한계를 극복하기 위한 **사용자 정의 유틸 함수**로,  
> 객체 안에 있는 **모든 중첩 객체까지 재귀적으로 순회하여 완전히 동결**시킵니다.

```js
// deepFreeze() 유틸 함수 정의 - 중첩 객체까지 모두 동결하여 완전한 불변 객체를 만드는 함수
function deepFreeze(obj) {
  Object.freeze(obj); // 객체 obj를 동결시켜 프로퍼티 추가, 삭제, 수정이 불가능(불변)하게 만듦

  // 객체의 프로퍼티들을 순회
  for (const key in obj) {
    const value = obj[key];

    // 만약 해당 프로퍼티가 객체이며(null 제외) 아직 동결되지 않았다면
    if (
      typeof value === "object" &&
      value !== null &&
      !Object.isFrozen(value)
    ) {
      // 해당 중첩 객체도 재귀적으로 deepFreeze() 실행
      deepFreeze(value);
    }
  }

  // 최종적으로 동결된 객체를 반환
  return obj;
}
```

```js
// deepFreeze() 를 활용한 중첩 객체 변경 방지
const user = { name: "Lee", profile: { age: 52 } };

// deepFreeze() 적용 전 상태 확인
console.log(Object.isFrozen(user));            // 출력: false
console.log(Object.isFrozen(user.profile));    // 출력: false

// deepFreeze() 적용
deepFreeze(user);

// deepFreeze() 적용 후 상태 확인
console.log(Object.isFrozen(user));            // 출력: true
console.log(Object.isFrozen(user.profile));    // 출력: true

// 최상위 프로퍼티 변경 시도 (무시됨)
user.name = "HaYeong";
console.log(user.name);                        // 출력: "Lee" - 변경되지 않음

// 중첩 객체 프로퍼티 변경 시도 (무시됨)
user.profile.age = 25;
console.log(user.profile.age);                 // 출력: 52 - 변경되지 않음

console.log(user);                             // 출력: { name: "Lee", profile: { age: 52 } }
```
