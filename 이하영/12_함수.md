# 함수(Function)

## 1. 함수란?
> 함수는 **특정 작업을 수행하는 코드 블록**으로, **이름**과 **매개변수**를 통해 정의되며, 필요할 때 **호출**하여 실행할 수 있습니다.

#### 📌 함수의 주요 특징
- 코드 재사용성: 동일안 작업을 **반복**할 때, 중복 코드를 피하고 함수로 **한 번만 정의하여 여러 번 사용**할 수 있습니다.
- 모듈화: 큰 프로그램을 여러 개의 작은 함수로 나누어 관리할 수 있어 **유지보수에 유리**합니다.
- 추상화: 함수 이름만 보고 어떤 동작을 하는지 쉽게 이해할 수 있어 **가독성이 높아집니다.**
- 클로저: 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여, **밖에서 호출되어도 스코프에 접근**할 수 있습니다.
  - 클로저에 대한 자세한 내용은 **`클로저`** 파트에서 다루겠습니다.

#### 📌 자바스크립트에서의 함수
- 자바스크립트 함수는 **일급 객체(First-class Object)** 입니다.
  - 함수는 **값처럼 다룰 수 있는 객체**로, 다음과 같은 동작이 가능합니다.
    - 변수에 저장
    - 다른 함수에 인수로 전달
    - 함수에서 반환값으로 사용
- 다른 객체와의 가장 큰 차이점은 **호출**할 수 있다는 것입니다.

### 🍀 함수 선언문이란?
> **`function`** 키워드로 정의하며, **이름이 있는 함수**입니다.  
> 코드가 실행되기 전에 미리 메모리에 등록되어 **호이스팅(어디서든 호출 가능)** 이 일어납니다.

```js
// 함수 선언문 예제 (어디서든 호출 가능 - 호이스팅 O)
sayHello();    // 출력: Hello!

function sayHello() {
  console.log("Hello!");
};

sayHello();    // 출력: Hello!
```

### 🍀 함수 표현식이란?
> 함수를 **변수에 할당하여 생성**하는 방식입니다.  
> 주로 **이름이 없는 익명 함수(Anonymous Function)** 형태로 사용되며, **호이스팅이 적용되지 않습니다.**

```js
// 함수 표현식 예제 (호이스팅 X)
sayHi();    // 출력: ReferenceError: Cannot access 'sayHi' before initialization

const sayHi = function() {
  console.log("Hi!");
};

sayHi();    // 출력: Hi!
```

### 🍀 생성자 함수란?
> **객체를 생성하기 위한 템플릿 역할을 하는 함수** 입니다.  
> 관례적으로 **대문자**로 시작하며, **`new`** 키워드와 함께 호출해야 **this가 새 객체를 가리키며, 인스턴스가 생성됩니다.**

```js
// 생성자 함수 예제
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// new 키워드로 객체 생성
const user = new Person("하영", 25);
console.log(user.name);    // 출력: 하영
```

### 🍀 매개변수(Parameter, 인자)란?
> 함수를 호출할 때, **함수 외부에서 내부로 데이터를 전달가히 위해 사용하는 변수**를 의미합니다.  
> 이때, 전달되는 실제 데이터는 **인자(Argument)** 라고 부릅니다.  
> 즉, 매개변수는 **함수 정의 시 선언되는 변수**, 인자는 **함수 호출 시 전달되는 값**입니다.

```js
// 매개변수(Parameter) 예제
function sum(a, b) {                // a, b -> 매개변수(parameter)
  return a + b;                     // a, b의 합을 반환
}

// 숫자형 인자 전달
console.log(sum(4, 4));             // 출력: 8

// 또 다른 숫자형 인자 전달
console.log(sum(10, 15));           // 출력: 25

// 문자열 인자 전달
console.log(sum("Ha", "Yeong"));    // 출력: HaYeong
```

#### 📌 매개변수의 기본값
> **기본값(Default value)** 이 지정된 매개변수는 **`undefined`** 가 전달되면, 기본값을 사용하지만,
> 매개변수에 아무것도 전달하지 않으면, **`undefined`** 가 할당됩니다.

```js
function sum(a, b = 1) {            // b의 기본값(default value)을 1로 설정

  // a: 호출 시 첫 번째 인자로 전달된 값 (없으면 undefined)
  // b: 호출 시 두 번째 인자가 없을 경우 기본값 1이 자동으로 할당됨
  return a + b;                     // a, b의 합을 반환
}

// 아무 인자도 전달하지 않음 → a는 undefined, b는 기본값 1 사용
// undefined + 1 = NaN(Not a Number)
console.log(sum())                  // 출력: NaN

// 첫 번째 인자만 전달 → a = 5, b는 기본값 1 사용
console.log(sum(5));                // 출력: 6

// 두 인자를 모두 전달 → a = 3, b = 2
console.log(sum(3, 2));             // 출력: 5
```

#### 📌 나머지 매개변수란?
> 함수에 전달된 인자의 개수가 **정해진 매개변수보다 많을 때**, **나머지 인자들을 배열 형태로 한 번에 받기 위해 사용하는 문법**입니다.
> 나머지 매개변수는 **`...`(전개 연산자)** 를 사용하며, 항상 **매개변수의 마지막에만 위치**해야 합니다.

```js
// 나머지 매개변수 예제
function sum(a, b, ...args) {
  console.log("a:", a);          // 첫 번째 인자
  console.log("b:", b);          // 두 번째 인자
  console.log("args:", args);    // 나머지 인자들(배열 형태)

  // a, b, 그리고 나머지 인자들을 모두 합산
  let total = a + b;
  for (let num of args) {
    total += num;
  }

  return total;
}

// 총 6개의 인자를 전달
console.log(sum(4, 5, 6, 7, 8, 9));
// 출력 결과
// a: 4
// b: 5
// args: [6, 7, 8, 9]
// 39
```

### 🍀 반환값(Return Value)란?
> 함수는 자신을 호출한 코드에게 수행한 결과를 **반환(return)** 할 수 있다. 이때 **반환된 값을 반환값(return value)** 이라고 합니다.  
> **`return`** 키워드는 함수를 종료하는 역할도 가지며, 따라서 **`return`** 키워드 아래 명령은 전혀 실행되지 않습니다.  
> **`return`** 키워드를 사용하지 않거나 반환할 데이터 작성을 생략하면, **`undefined`** 가 반환됩니다.

```js
// 반환값(Return Value) 예제
function sayHello() {
  return "Hi!"              // 여기서 함수가 종료됨
  console.log("Hello!");    // 따라서 이 코드는 실행되지 않음
};

const hi = sayHello();      // 반환된 "Hi!"를 hi 변수에 저장
console.log(hi);            // 출력: Hi!

sayHello();                 // console.log("Hello!"); 가 실행되지 않았기 때문에 출력되지 않음
```

## 2. 함수 호이스팅이란?
> 자바스크립트에서 **함수 선언문이 코드 실행 전에 미리 메모리에 등록되어**,  
> **선언부가 유효범위(Scope) 최상단으로 끌어올려진 것처럼 동작하는 현상**을 말합니다.

### 🍀 호이스팅이 일어나는 이유
- 자바스크립트의 **변수 생성(Instantiation)** 과 **초기화(Initialization)** 의 작업이 분리돼서 진행되기 때문입니다.
  - **`함수 선언문`** 은 **전체 함수가 메모리에 저장**되지만,
  - **`함수 표현식`** 은 **변수만 등록되고 값(함수)은 나중에 할당**됩니다.

#### ✏️ 함수 선언문
```js
// 함수 선언문 예제 (어디서든 호출 가능 - 호이스팅 O)
sayHello();    // 출력: Hello!
sayHi();       // 출력: Hi!

function sayHello() {
  console.log("Hello!");
};

function sayHi() {
  console.log("Hi!");
};

sayHello();    // 출력: Hello!
sayHi();       // 출력: Hi!
```

#### ✏️ 함수 표현식
```js
// 함수 표현식 예제 (호이스팅 X)
sayHello();    // 출력: ReferenceError: Cannot access 'sayHello' before initialization
sayHi();       // 출력: ReferenceError: Cannot access 'sayHi' before initialization

const sayHello = function() {
  console.log("Hello!");
};

const sayHi = function() {
  console.log("Hi!");
};

sayHello();    // 출력: Hello!
sayHi();       // 출력: Hi!
```

#### 📌 함수 선언문은 오류가 발생하지 않지만, 표현식은 오류가 발생하는 이유는?
> 실제 자바스크립트 **컴파일**은 **함수 선언과 변수 선언을 먼저 메모리에 등록(위로 호이스팅)** 되기 때문입니다.  
> 따라서 **함수 선언문**과 **함수 표현식**은 **호이스팅되는 방식이 다릅니다.**

```js
// 자바스크립트 컴파일 시 내부 동작 예시
function sayHello() {
  console.log("Hello!");
};

// TDZ(Temporal Dead Zone, 일시적 사각지대)에 존재(초기화되지 않은 상태)
const sayHi;    // 실제 코드에는 존재하지 않지만, 이해를 돕기 위한 시각적 표현

sayHello();     // 출력: Hello!
sayHi();        // 출력: ReferenceError: Cannot access 'sayHi' before initialization

sayHi = function() {
  console.log("Hi!");
};

sayHello();     // 출력: Hello!
sayHi();        // 출력: Hi!
```

> 💡 **정리**
> - **함수 선언문(function)**
>   - 선언부 자체가 **메모리에 미리 등록(호이스팅)** 되어 **호이스팅 시점부터 바로 호출이 가능합니다.**
> - **함수 표현식(const sayHi = function() {})**
>   - 변수 **`sayHi`** 는 호이스팅 시 **TDZ(일시적 사각지대)** 에 존재하며,
>   - **초기화 되기 전에는 접근 불가 -> ReferenceError 오류가 발생합니다.**

### 🍀 생성자 함수의 호이스팅
> 함수 **선언문 형태**의 생성자 함수라면 **호이스팅이 일어나며**,  
> 함수 **표현식 형태**의 생성자 함수라면 **호이스팅되지 않습니다.**  
> 즉, 생성자 함수의 호이스팅은 **함수가 어떤 형태로 정의되었는지가 핵심**입니다.

#### ✏️ 함수 선언문 형태의 생성자 함수(호이스팅 O)
```js
// 함수 선언문 형태 예제
const user = new Person("하영", 25);    // 정상 동작 (호이스팅 O)

function Person(name, age) {
  this.name = name;
  this.age = age;
}

console.log(user.name);                 // 출력: 하영
```

#### ✏️ 함수 표현식 형태의 생성자 함수(호이스팅 X)
```js
// 함수 표현식 형태 예제
// const person은 함수 표현식이므로, TDZ에 있어서 초기화되기 전에는 접근할 수 없음
const user = new Person("하영", 25);    // ReferenceError: Cannot access 'Person' before initialization

const Person = function(name, age) {
  this.name = name;
  this.age = age;
};

// 위 코드에서 const user = new Person("하영", 25); 부분이 실행되지 못했기 때문에 user 변수는 선언조차 되지 않음
console.log(user.name);                 // ReferenceError: user is not defined
```

## 3. 일급 객체(First-class Object)란?
> **다른 객체와 동등하게 다룰 수 있는 객체**를 의미하며, 다음 **세 가지 특징**을 가집니다.
> - **변수에 저장 가능**: 객체를 **변수나 데이터 구조에 할당**할 수 있어야 합니다.
> - **함수의 매개변수로 전달 가능**: 객체를 **다른 함수의 매개변수(파라미터(parameter), 인수(argument))로 전달**할 수 있어야 합니다.
> - **함수의 리턴값(반환값)으로 사용 가능**: 함수가 **객체를 리턴값으로 사용**할 수 있어야 합니다.

### 🍀 변수에 저장 가능
> 함수 표현식을 변수에 자유롭게 할당할 수 있습니다.

```js
// 함수 표현식을 const 변수에 할당
// sayHello 변수는 함수 자체를 값으로 저장
const sayHello = function() {
  console.log("Hello!");
};

// sayHello 변수에 저장된 함수 호출
sayHello();    // 출력: Hello!
```

### 🍀 함수의 매개변수로 전달 가능
> 함수(콜백)를 다른 함수의 매개변수로 전달할 수 있습니다.

```js
// sayHello 함수 정의 (함수 표현식)
const sayHello = function() {
  console.log("Hello!");
};

// print 함수는 매개변수 func로 함수를 전달받음
function print(func) {
	func();           // 전달받은 함수를 실행
}

// sayHello 함수를 print 함수의 매개변수로 전달
// 이때 sayHello 함수가 콜백 함수 역할을 함
print(sayHello);    // 출력: Hello!
```

### 🍀 함수의 리턴값(반환값)으로 사용 가능
> 함수가 다른 함수를 반환할 수 있습니다. (클로저 활용)

```js
// sayHello 함수가 내부 함수를 반환 (함수 표현식)
const sayHello = function() {
  // 내부 함수 반환
  return function() {
    console.log("Hi!");
  };
};

const hello = sayHello();    // sayHello를 호출하면 내부 함수가 반환

// 반환된 내부 함수 호출
hello();                     // 출력: Hi!
```

## 6. 함수 객체의 프로퍼티
> 자바스크립트에서 **함수는 일급 객체**이기 때문에 함수도 **프로퍼티(속성)** 를 가질 수 있습니다.

## 7. 함수의 다양한 형태





















