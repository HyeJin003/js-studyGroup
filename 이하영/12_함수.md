# 함수(Function)

## 1. 함수란?
> 함수는 **특정 작업을 수행하는 코드 블록**으로, **이름**과 **매개변수**를 통해 정의되며, 필요할 때 **호출**하여 실행할 수 있습니다.

#### 📌 함수의 주요 특징
- 코드 재사용성: 동일안 작업을 **반복**할 때, 중복 코드를 피하고 함수로 **한 번만 정의하여 여러 번 사용**할 수 있습니다.
- 모듈화: 큰 프로그램을 여러 개의 작은 함수로 나누어 관리할 수 있어 **유지보수에 유리**합니다.
- 추상화: 함수 이름만 보고 어떤 동작을 하는지 쉽게 이해할 수 있어 **가독성이 높아집니다.**
- 클로저: 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여, **밖에서 호출되어도 스코프에 접근**할 수 있습니다.
  - 클로저에 대한 자세한 내용은 **`클로저`** 파트에서 다루겠습니다.

#### 📌 자바스크립트에서의 함수
- 자바스크립트 함수는 **일급 객체(First-class Object)** 입니다.
  - 함수는 **값처럼 다룰 수 있는 객체**로, 다음과 같은 동작이 가능합니다.
    - 변수에 저장
    - 다른 함수에 인수로 전달
    - 함수에서 반환값으로 사용
- 다른 객체와의 가장 큰 차이점은 **호출**할 수 있다는 것입니다.

### 🍀 함수 선언문이란?
> **`function`** 키워드로 정의하며, **이름이 있는 함수**입니다.  
> 코드가 실행되기 전에 미리 메모리에 등록되어 **호이스팅(어디서든 호출 가능)** 이 일어납니다.

```js
// 함수 선언문 예제 (어디서든 호출 가능 - 호이스팅 O)
sayHello();    // 출력: Hello!

function sayHello() {
  console.log("Hello!");
};

sayHello();    // 출력: Hello!
```

### 🍀 함수 표현식이란?
> 함수를 **변수에 할당하여 생성**하는 방식입니다.  
> 주로 **이름이 없는 익명 함수(Anonymous Function)** 형태로 사용되며, **호이스팅이 적용되지 않습니다.**

```js
// 함수 표현식 예제 (호이스팅 X)
sayHi();    // 출력: ReferenceError: Cannot access 'sayHi' before initialization

const sayHi = function() {
  console.log("Hi!");
};

sayHi();    // 출력: Hi!
```

### 🍀 생성자 함수란?
> **객체를 생성하기 위한 템플릿 역할을 하는 함수** 입니다.  
> 관례적으로 **대문자**로 시작하며, **`new`** 키워드와 함께 호출해야 **this가 새 객체를 가리키며, 인스턴스가 생성됩니다.**

```js
// 생성자 함수 예제
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// new 키워드로 객체 생성
const user = new Person("하영", 25);
console.log(user.name);    // 출력: 하영
```

### 🍀 매개변수(Parameter, 인자)란?
> 함수를 호출할 때, **함수 외부에서 내부로 데이터를 전달가히 위해 사용하는 변수**를 의미합니다.  
> 이때, 전달되는 실제 데이터는 **인자(Argument)** 라고 부릅니다.  
> 즉, 매개변수는 **함수 정의 시 선언되는 변수**, 인자는 **함수 호출 시 전달되는 값**입니다.

```js
// 매개변수(Parameter) 예제
function sum(a, b) {                // a, b -> 매개변수(parameter)
  return a + b;                     // a, b의 합을 반환
}

// 숫자형 인자 전달
console.log(sum(4, 4));             // 출력: 8

// 또 다른 숫자형 인자 전달
console.log(sum(10, 15));           // 출력: 25

// 문자열 인자 전달
console.log(sum("Ha", "Yeong"));    // 출력: HaYeong
```

#### 📌 매개변수의 기본값
> **기본값(Default value)** 이 지정된 매개변수는 **`undefined`** 가 전달되면, 기본값을 사용하지만,  
> 매개변수에 아무것도 전달하지 않으면, **`undefined`** 가 할당됩니다.

```js
function sum(a, b = 1) {            // b의 기본값(default value)을 1로 설정

  // a: 호출 시 첫 번째 인자로 전달된 값 (없으면 undefined)
  // b: 호출 시 두 번째 인자가 없을 경우 기본값 1이 자동으로 할당됨
  return a + b;                     // a, b의 합을 반환
}

// 아무 인자도 전달하지 않음 → a는 undefined, b는 기본값 1 사용
// undefined + 1 = NaN(Not a Number)
console.log(sum())                  // 출력: NaN

// 첫 번째 인자만 전달 → a = 5, b는 기본값 1 사용
console.log(sum(5));                // 출력: 6

// 두 인자를 모두 전달 → a = 3, b = 2
console.log(sum(3, 2));             // 출력: 5
```

#### 📌 나머지 매개변수란?
> 함수에 전달된 인자의 개수가 **정해진 매개변수보다 많을 때**, **나머지 인자들을 배열 형태로 한 번에 받기 위해 사용하는 문법**입니다.  
> 나머지 매개변수는 **`...`(스프레드 연산자)** 를 사용하며, 항상 **매개변수의 마지막에만 위치**해야 합니다.

```js
// 나머지 매개변수 예제
function sum(a, b, ...args) {
  console.log("a:", a);          // 첫 번째 인자
  console.log("b:", b);          // 두 번째 인자
  console.log("args:", args);    // 나머지 인자들(배열 형태)

  // a, b, 그리고 나머지 인자들을 모두 합산
  let total = a + b;
  for (let num of args) {
    total += num;
  }

  return total;
}

// 총 6개의 인자를 전달
console.log(sum(4, 5, 6, 7, 8, 9));
// 출력 결과
// a: 4
// b: 5
// args: [6, 7, 8, 9]
// 39
```

### 🍀 인자 전달 방식(Call by Value vs Call by Reference)
> 자바스크립트에서 함수 호출 시 인자를 전달하는 방식은 **`값에 의한 전달(Call by Value)`** **`참조에 의한 전달(Call by Reference)`** 두 가지로 나뉩니다.  
> 각 방식은 **데이터가 함수 내부로 어떻게 전달되고, 원본 값이 변경되는지 여부**에서 차이를 보입니다.

#### 📌 Call by Value(값에 의한 전달)
> 함수에 **값 자체를 복사하여 전달하는 방식**이며, 함수 내부에서 매개변수의 값을 변경해도 **원래 변수에는 영향을 주지 않습니다.**  
> 주로 **기본 자료형(Primitive Type)** **`숫자(Number)`** **`문자열(String)`** **`부울(Boolean)`** 등이 여기에 해당합니다.

```js
// Call by Value(값에 의한 전달) 예제
function changeValue(age) {
  age = 25;								// 매개변수 age의 값만 변경됨 (복사본)
  console.log("함수 내부 age:", age);
}

let num = 50;							// 원본 변수(num) 선언

changeValue(num);						// num의 값(50)이 복사되어 전달됨

console.log("함수 외부 num:", num);		// 함수 외부의 num은 변경되지 않음

// 출력
// 함수 내부 x: 25
// 함수 외부 num: 50
```
- **`num`** 의 값이 함수 내부로 **복사되어 전달**되기 때문에, 함수 안에서 **`age`** 를 수정해 원본 **`num`** 에는 영향을 주지 않습니다.
- 즉, **`age`**는 **`num`** 의 **복사본**일 뿐, 같은 메모리 공간을 가리키지 않아요.

#### 📌 Call by Reference(참조에 의한 전달)
> 함수에 **값의 참조(주소)를 전달하는 방식**이며, 함수 내부에서 매개변수로 전달된 객체나 배열을 변경하면 **원래 데이터도 함께 변경됩니다.**  
> 주로 **`객체(Object)`** **`배열(Array)`** 등 **참조형(Reference Type)** 데이터가 이에 해당합니다.

```js
// Call by Reference(참조에 의한 전달) 예제 - 객체를 매개변수로 전달하는 함수
function changeObject(obj) {
  // 전달받은 객체의 프로퍼티 값을 직접 수정
  obj.name = "HaYeong";     				// 원본 객체의 name 프로퍼티가 변경됨
  console.log("함수 내부 obj:", obj);		// 변경된 값 출력
}

let user = { name: "Lee" };					// 원본 객체(user) 선언

changeObject(user);							// 함수 호출 시, 객체의 참조(주소)가 전달됨

console.log("함수 외부 user:", user);		// 함수 호출 이후에도 원본 객체가 변경되어 있음

// 출력
// 함수 내부 obj: { name: "HaYeong" }
// 함수 외부 user: { name: "HaYeong" }
```
- **`user`** 객체의 참조(주소)가 함수로 전달되므로, 함수 내부에서 **`obj.name = "HaYeong";`** 처럼 프로퍼티를 수정하면 **원본 객체도 변경**됩니다.
- 하지만 **`obj = {...}`** 처럼 **새로운 객체를 재할당**하면, 이는 함수 내부의 **`obj`** 변수만 다른 객체를 가리키게 되므로 **원본 객체는 변경되지 않습니다.**

### 🍀 반환값(Return Value)란?
> 함수는 자신을 호출한 코드에게 수행한 결과를 **반환(return)** 할 수 있다. 이때 **반환된 값을 반환값(return value)** 이라고 합니다.  
> **`return`** 키워드는 함수를 종료하는 역할도 가지며, 따라서 **`return`** 키워드 아래 명령은 전혀 실행되지 않습니다.  
> **`return`** 키워드를 사용하지 않거나 반환할 데이터 작성을 생략하면, **`undefined`** 가 반환됩니다.

```js
// 반환값(Return Value) 예제
function sayHello() {
  return "Hi!"              // 여기서 함수가 종료됨
  console.log("Hello!");    // 따라서 이 코드는 실행되지 않음
};

const hi = sayHello();      // 반환된 "Hi!"를 hi 변수에 저장
console.log(hi);            // 출력: Hi!

sayHello();                 // console.log("Hello!"); 가 실행되지 않았기 때문에 출력되지 않음
```

## 2. 함수 호이스팅이란?
> 자바스크립트에서 **함수 선언문이 코드 실행 전에 미리 메모리에 등록되어**,  
> **선언부가 유효범위(Scope) 최상단으로 끌어올려진 것처럼 동작하는 현상**을 말합니다.

### 🍀 호이스팅이 일어나는 이유
- 자바스크립트의 **변수 생성(Instantiation)** 과 **초기화(Initialization)** 의 작업이 분리돼서 진행되기 때문입니다.
  - **`함수 선언문`** 은 **전체 함수가 메모리에 저장**되지만,
  - **`함수 표현식`** 은 **변수만 등록되고 값(함수)은 나중에 할당**됩니다.

#### ✏️ 함수 선언문
```js
// 함수 선언문 예제 (어디서든 호출 가능 - 호이스팅 O)
sayHello();    // 출력: Hello!
sayHi();       // 출력: Hi!

function sayHello() {
  console.log("Hello!");
};

function sayHi() {
  console.log("Hi!");
};

sayHello();    // 출력: Hello!
sayHi();       // 출력: Hi!
```

#### ✏️ 함수 표현식
```js
// 함수 표현식 예제 (호이스팅 X)
sayHello();    // 출력: ReferenceError: Cannot access 'sayHello' before initialization
sayHi();       // 출력: ReferenceError: Cannot access 'sayHi' before initialization

const sayHello = function() {
  console.log("Hello!");
};

const sayHi = function() {
  console.log("Hi!");
};

sayHello();    // 출력: Hello!
sayHi();       // 출력: Hi!
```

#### ❓ 함수 선언문은 오류가 발생하지 않지만, 표현식은 오류가 발생하는 이유는?
> 실제 자바스크립트 **컴파일**은 **함수 선언과 변수 선언을 먼저 메모리에 등록(위로 호이스팅)** 되기 때문입니다.  
> 따라서 **함수 선언문**과 **함수 표현식**은 **호이스팅되는 방식이 다릅니다.**

```js
// 자바스크립트 컴파일 시 내부 동작 예시
function sayHello() {
  console.log("Hello!");
};

// TDZ(Temporal Dead Zone, 일시적 사각지대)에 존재(초기화되지 않은 상태)
const sayHi;    // 실제 코드에는 존재하지 않지만, 이해를 돕기 위한 시각적 표현

sayHello();     // 출력: Hello!
sayHi();        // 출력: ReferenceError: Cannot access 'sayHi' before initialization

sayHi = function() {
  console.log("Hi!");
};

sayHello();     // 출력: Hello!
sayHi();        // 출력: Hi!
```

> 💡 **정리**
> - **함수 선언문(function)**
>   - 선언부 자체가 **메모리에 미리 등록(호이스팅)** 되어 **호이스팅 시점부터 바로 호출이 가능합니다.**
> - **함수 표현식(const sayHi = function() {})**
>   - 변수 **`sayHi`** 는 호이스팅 시 **TDZ(일시적 사각지대)** 에 존재하며,
>   - **초기화 되기 전에는 접근 불가 -> ReferenceError 오류가 발생합니다.**

### 🍀 생성자 함수의 호이스팅
> 함수 **선언문 형태**의 생성자 함수라면 **호이스팅이 일어나며**,  
> 함수 **표현식 형태**의 생성자 함수라면 **호이스팅되지 않습니다.**  
> 즉, 생성자 함수의 호이스팅은 **함수가 어떤 형태로 정의되었는지가 핵심**입니다.

#### ✏️ 함수 선언문 형태의 생성자 함수(호이스팅 O)
```js
// 함수 선언문 형태 예제
const user = new Person("하영", 25);    // 정상 동작 (호이스팅 O)

function Person(name, age) {
  this.name = name;
  this.age = age;
}

console.log(user.name);                 // 출력: 하영
```

#### ✏️ 함수 표현식 형태의 생성자 함수(호이스팅 X)
```js
// 함수 표현식 형태 예제
// const person은 함수 표현식이므로, TDZ에 있어서 초기화되기 전에는 접근할 수 없음
const user = new Person("하영", 25);    // ReferenceError: Cannot access 'Person' before initialization

const Person = function(name, age) {
  this.name = name;
  this.age = age;
};

// 위 코드에서 const user = new Person("하영", 25); 부분이 실행되지 못했기 때문에 user 변수는 선언조차 되지 않음
console.log(user.name);                 // ReferenceError: user is not defined
```

## 3. 일급 객체(First-class Object)란?
> **다른 객체와 동등하게 다룰 수 있는 객체**를 의미하며, 다음 **세 가지 특징**을 가집니다.
> - **변수에 저장 가능**: 객체를 **변수나 데이터 구조에 할당**할 수 있어야 합니다.
> - **함수의 매개변수로 전달 가능**: 객체를 **다른 함수의 매개변수(파라미터(parameter), 인수(argument))로 전달**할 수 있어야 합니다.
> - **함수의 리턴값(반환값)으로 사용 가능**: 함수가 **객체를 리턴값으로 사용**할 수 있어야 합니다.

### 🍀 변수에 저장 가능
> 함수 표현식을 변수에 자유롭게 할당할 수 있습니다.

```js
// 함수 표현식을 const 변수에 할당
// sayHello 변수는 함수 자체를 값으로 저장
const sayHello = function() {
  console.log("Hello!");
};

// sayHello 변수에 저장된 함수 호출
sayHello();    // 출력: Hello!
```

### 🍀 함수의 매개변수로 전달 가능
> 함수(콜백)를 다른 함수의 매개변수로 전달할 수 있습니다.

```js
// sayHello 함수 정의 (함수 표현식)
const sayHello = function() {
  console.log("Hello!");
};

// print 함수는 매개변수 func로 함수를 전달받음
function print(func) {
	func();           // 전달받은 함수를 실행
}

// sayHello 함수를 print 함수의 매개변수로 전달
// 이때 sayHello 함수가 콜백 함수 역할을 함
print(sayHello);    // 출력: Hello!
```

### 🍀 함수의 리턴값(반환값)으로 사용 가능
> 함수가 다른 함수를 반환할 수 있습니다. (클로저 활용)

```js
// sayHello 함수가 내부 함수를 반환 (함수 표현식)
const sayHello = function() {
  // 내부 함수 반환
  return function() {
    console.log("Hi!");
  };
};

const hello = sayHello();    // sayHello를 호출하면 내부 함수가 반환

// 반환된 내부 함수 호출
hello();                     // 출력: Hi!
```

## 4. 함수 객체의 프로퍼티
> 자바스크립트에서 **함수는 일급 객체**이므로, 함수도 **프로퍼티(속성)** 를 가질 수 있습니다.

### 🍀 arguments 프로퍼티
> 함수가 호출될 때 전달된 **인수(argument)** 들의 정보를 담고 있는 **순회가능한(iterable)** **`유사 배열 객체(array-like object)`** 입니다.  
> 함수 내부에서 지역 변수처럼 사용 가능하며, 함수 외부에서는 접근할 수 없으며,  
> 특히 **매개변수 갯수가 정해지지 않은 가변 인자 함수를 구현할 때 유용**합니다.

```js
// arguments 프로퍼티 활용
function sum() {
  var res = 0;

  for (var i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }

  return res;
}

console.log(sum());        								// 출력: 0
console.log(sum(1, 2));    								// 출력: 3
console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));		// 출력: 55
```

#### ⚠️ `arguments` 는 배열처럼 보이지만 배열이 아니기 때문에, `forEach` `map` 같은 배열 메서드를 바로 사용할 수 없습니다.

#### ✏️ 방법 1: Array.prototype.slice.call
```js
// 방법 1: Array.prototype.slice.call
function sum1() {
  // arguments는 유사배열이므로 직접 배열 메서드를 사용할 수 없음.
  // Array.prototype.slice.call(arguments)는 arguments를 얕은 복사하여 진짜 배열로 반환함.
  const args = Array.prototype.slice.call(arguments);

  // args는 실제 배열로 반환 됐기 때문 reduce 등 배열 메서드를 그대로 사용 가능
  return args.reduce(function (acc, cur) {
	return acc + cur;
  }, 0); // 초기값 0을 명시하는 것이 안전
}

console.log(sum1(1, 2, 3, 4, 5)); // 출력: 15
```

#### ✏️ 방법2 : Array.prototype.reduce.apply
```js
// 방법2 : Array.prototype.reduce.apply
function sum2() {
  // Array.prototype.reduce.apply(thisArg, [argsForReduce...])
  // - 첫 번째 인자(thisArg): reduce를 적용할 객체(arguments)
  // - 두 번째 인자([argsForReduce...]): reduce에 전달할 인수들 [reduce의 콜백 함수, 초기값]
  // 즉, arguments를 배열로 바꾸지 않고 'reduce'를 직접 실행하는 방식
  return Array.prototype.reduce.apply(arguments, [
    function (acc, cur) { return acc + cur; },			// reduce의 콜백
    0                                          			// 초기값 0을 명시하는 것이 안전
  ]);
}

console.log(sum2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));		// 출력: 55
```

#### ✏️ 방법 3: 스프레드 연산자(...)
```js
// 방법 3: 스프레 연산자(...)
function sum3() {
  // 스프레드 연산자로 arguments를 배열로 변환
  const args = [...arguments];

  // 일반 배열 메서드 사용
  return args.reduce(function (acc, cur) {
	return acc + cur
  });
}

console.log(sum3(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)); // 출력: 120
```
> #### 💡 `arguments` 정리  
> **`arguments`** 는 배열처럼 동작하지만 실제 배열이 아닙니다.  
> 배열 메서드를 사용하려면 **`slice()`** **`apply()`** **`스프레드 연산자(...)`** 중 하나를 활용해야 합니다.  
> 가장 간결하고 가독성이 좋은 **`스프레드 연산자(...)`** 를 사용하는 것이 좋습니다.

### 🍀 length 프로퍼티
> **함수 정의 시 작성된 매개변수(parameter)의 개수**를 나타내는 프로퍼티입니다.  
> 즉, **함수를 선언할 때** 괄호 안에 적은 매개변수의 수를 반환합니다.

```js
// length 프로퍼티 활용
function zero() {}
console.log(zero.length);		// 출력: 0 (매개변수가 존재하지 않음)

function one(x) {
  return x;
}
console.log(one.length);		// 출력: 1 (매개변수가 존재하지 않음)

function two(x, y) {
  return x + y;
}
console.log(two.length);		// 출력: 2 (매개변수가 존재하지 않음)
```

#### ⚠️ **`length`** 는 함수 정의 시점의 매개변수 개수를 의미합니다.
> 함수 호출 시 전달된 **인자(arguments)** 의 개수인 **`arguments.length`** 와는 다릅니다.

```js
// 정의된 매개변수 개수와 전달된 이자 개수
function example(a, b) {
  console.log("정의된 매개변수 개수: ", example.length);
  console.log("전달된 인자 개수: ", arguments.length);
}

example(1);         	// 출력: 정의된 매개변수 개수: 2 / 전달된 인자 개수: 1
example(1, 2, 3);		// 출력: 정의된 매개변수 개수: 2 / 전달된 인자 개수: 3
```

#### ⚠️ 또한 `length` 는 일반 매개변수만 계산하고, 나머지 매개변수는 제외합니다.

```js
// 일반 매개변수와 나머지 매개변수의 차이
function ten(x, y, ...args) {
  return x + y;
}
console.log(ten.length);		// 출력: 2 (나머지 매개변수는 포함되지 않음)
```

### 🍀 name 프로퍼티
> **함수의 이름을 나타내는 프로퍼티**입니다.  
> 기명 함수(named function)의 경우 **함수명을 값**으로 가지고,  
> 익명 함수(anonymous function)의 경우 **빈 문자열(`""`)을 값**으로 가집니다.

#### ✏️ 기명 함수
> **이름이 있는 함수**를 말하며, **디버깅, 재귀 호출, 스택 추적** 등에 유용합니다.

```js
// 기명 함수 선언문과 표현식
function namedFunc() {
  console.log("이름이 있는 함수");
}

console.log(namedFunc.name);			// 출력: namedFunc

let namedFunc2 = function multiply(a, b) {
  return a * b;
};

console.log(namedFunc2.name);			// 출력: multiply
```

#### ✏️ 익명 함수
> **이름이 없는 함수**를 말하며, **변수에 할당**하거나, **콜백 함수**로 전달할 때 사용합니다.

```js
// 익명 함수 선언문과 표현식
function anonymousFunc1() {
  console.log("이름이 없는 함수");
}

console.log(anonymousFunc1.name);		// 출력: ""
										// ES6~ 출력: anonymousFunc1

let anonymousFunc2 = function(a, b) {
  return a + b;
};

console.log(anonymousFunc2.name);		// 출력: ""
										// ES6~ 출력: anonymousFunc2
```
- 함수 자체에는 이름이 없기 때문에 **내부적으로는 익명 함수**입니다.
- 하지만 ES6부터는 **자동으로 변수 이름을 함수의 name 프로퍼티로 지정**해줍니다.

### 🍀 prototype 프로퍼티
> **`prototype` 프로퍼티**는 **생성자(constructor)** 로 호출할 수 있는 **함수 객체만이 가지는 프로퍼티**입니다.  
> 일반 객체는 없고, 함수 객체만이 **`prototype`** 을 가지며, 생성자 함수로 사용 가능한 함수는 **`prototype`** 을 가지지만,  
> **화살표 함수**나 **메서드 축약 표현**은 **`prototype`** 이 존재하지 않아 **생성자로 사용할 수 없습니다.**

```js
// 일반 함수 - prototype을 가짐
function obj1() {}
// 내부적으로 obj1.prototype = { constructor: obj1 } 형태를 가짐
// 콘솔에는 {}처럼 보이지만 실제로는 constructor 프로퍼티를 포함
console.log(obj1.prototype);				// 출력: {}
console.log(typeof obj1.prototype);			// 출력: object

// 화살표 함수 - prototype 없음
const obj2 = () => {};
console.log(obj2.prototype);				// 출력: undefined
console.log(typeof obj2.prototype);			// 출력: undefined

// 메서드 축약 표현 - prototype 없음
const obj3 = {
  sayHello() {}
};
console.log(obj3.sayHello.prototype);		// 출력: undefined
console.log(typeof obj3.prototype);			// 출력: undefined
```

### 🍀 Object.getPrototypeOf() / Object.setPrototypeOf()
> 객체의 **프로토타입에 접근하거나 변경**할 때 사용되는 **표준 메서드**입니다.  
> 이전에는 **`__proto`** 접근자 프로퍼티를 사용했지만, 이는 **비표준**으로 취급되며,
> 현재는  **`Object.getPrototypeOf()`** **`Object.setPrototypeOf()`** 를 사용하는 것이 권장됩니다.

#### ✏️ Object.getPrototypeOf()
> 주어진 객체의 **프로토타입을 반환**합니다.

```js
const obj = {};
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true
```
- **`Object.getPrototypeOf(obj)`** 는 **`obj`** 의 내부 슬롯 **`[[Prototype]]`** 을 읽습니다.
- 즉, **`obj.__proto__`** 와 같은 값을 반환하지만 표준적이고 안전한 방법입니다.

#### ✏️ Object.setPrototypeOf()
> 주어진 객체의 **프로토타입을 새 객체로 변경**합니다.

```js
const parent = { greet() { console.log("Hello!"); } };
const child = {};

Object.setPrototypeOf(child, parent);
child.greet();		// 출력: Hello!
```
- **`child`** 의 프로토타입을 **`parent`** 로 바꿔서 **`child`** 가 **`parent`** 의 속성(**`greet`**)을 상속 받습니다.
- 즉, **`child.__proto__ = parent;`** 와 같은 동작을 하지만, 표준화된 방식입니다.

#### ⚠️ `Object.setPrototypeOf()` 는 런타임 중 객체의 상속 구조를 변경하지 때문에 성능 저하를 유발할 수 있습니다.
- 가능한 경우 **객체 생성 시점에 프로토타입을 지정**하는 방식이 훨씬 효율적입니다.

```js
// 권장 방식: Object.create로 프로토타입을 지정한 객체 생성
const parent = { greet() { console.log("Hello!"); } };
const child = Object.create(parent);

child.greet();		// 출력: Hello!
```

## 5. 함수의 다양한 형태
> 자바스크립트의 함수는 단순히 호출되는 용도뿐 아니라,  
> **특정 시점에 자동 실행하거나, 함수 안에서 정의하거나, 자신을 다시 호출하거나, 다른 함수의 인수로 전달되는 등** 여러 형태로 사용될 수 있습니다.

### 🍀 즉시 실행 함수(Immediately Invoke Function Expression)
> 함수를 **정의와 동시에 실행**되는 함수이며, 최초 한 번만 호출되고 다시 호출할 수는 없습니다.
> 한 번만 실행할 초기화 코드나, 변수의 **독립적 스코프(범위)** 를 만들 때 자주 사용됩니다.

```js
var msg = "전역 변수";

// 즉시 실행 함수는 함수 내부에서만 접근할 수 있음
(function() {
  var msg = "즉시 실행 함수 실행";
  console.log(msg);			// 출력: 즉시 실행 함수 실행
})();

// 외부에서 접근 시 전역 변수를 실행
console.log(msg);			// 출력: 전역 변수
```
- 즉시 실행 함수는 실행과 동시에 **자기만의 독립된 공간(스코프)** 을 만들어 그 안의 변수, 함수 등이 외부와 **겹치지 않게 보호**되는 역할을 합니다.

#### 💡 독립적 스코프란?
> 즉시 실행 함수가 한 번 실행될 때 만들어지는 **독립적인 지역 변수 영역**을 뜻합니다.
> 이를 통해 **전역 변수 오염을 방지하고, 임시 변수나 초기화 코드**를 안전하게 처리할 수 있습니다.

### 🍀 내부 함수(Inner Function)
> 함수 **내부에서 정의된 함수**를 내부 함수라고 합니다.  
> 자신을 포함하는 **부모 함수의 변수**에 접근할 수 있지만, 부모 함수는 **내부 함수의 변수**에 접근할 수 없습니다.  
> 이를 통해 특정 기능을 부모 함수 안에 감추고, **외부에서 직접 접근하지 못하도록 보호**할 수 있습니다.

```js
// 
function outer() {
  const message = "부모 변수";

  function inner() {
    console.log(message);		// 내부 함수에서 부모 함수 변수 접근 가능
  }

  inner();						// 내부 함수 호출은 부모 함수 안에서만 가능
}

outer();						// 출력: 부모 변수

inner();						// 출력: ReferenceError: inner is not defined  (외부에서는 접근 불가)
```

### 🍀 재귀 함수(Recusive Function)
> **내부에서 자기 자신을 다시 호출하는 함수**입니다.  
> 반복되는 작업을 반복문(for, while) 대신 **함수 호출 방식으로 구현**할 수 있습니다.

```js
// 재귀 함수를 이용한 팩토리얼 예제
function factorial(n) {
  if (n === 1) return 1;		// 종료 조건 : 더 이상 재귀 호출하지 않고 1을 반환
  return n * factorial(n - 1);
}

// 팩토리얼 계산 흐름
// factorial(5):
// 5 * factorial(4)
// 4 * factorial(3)
// 3 * factorial(2)
// 2 * factorial(1)
// 5 * 4 * 3 * 2 * 1 = 120

console.log(factorial(5));		// 출력: 120
```

#### ⚠️ 재귀 함수 사용 시 주의!
> 종료 조건이 없으면 함수가 **자기 자신을 무한으로 호출**하게 되어 **프로그램이 멈추거나 스택 오버플로우가 발생**합니다.  
> 따라서 재귀 함수를 만들 때는 **반드시 종료 조건을 명시**해야 합니다.

#### ❓ 스택 오버플로우(Stack Overflow)란?
> 함수 호출이 너무 많이 반복되거나 종료 조건 없이 계속 호출되어 **메모리 스택 영역이 가득 차 버리는 현상**을 말합니다.  
> 이 상태가 되면 **프로그램이 정상적으로 동작할 수 없으며, 오류가 발생**하게 됩니다.

### 🍀 콜백 함수(Callback Function)
> **함수를 매개변수로 전달하여, 전달받은 함수가 특정 시점에 호출되도록 하는 것**을 콜백 함수라고 합니다.  
> 즉, 일반 변수나 값을 전달하는 것이 아니라, **함수 자체를 다른 함수(매개변수)에 전달**하는 것을 의미합니다.

#### ✏️ 콜백 함수의 동작 원리

```js
function greeting(name) {
  console.log(`Hello, ${name}`);
}

function processUser(callback) {		// callback 매개변수를 선언
  const user = "HaYeong";				// user 값을 준비
  callback(user);     					// 전달받은 함수를 원하는 시점에 실행
}

// processUser를 호출할 때 greeting 함수를 전달
processUser(greeting);   				// 출력: Hello, HaYeong
```
1. **`greeting`** 함수는 **먼저 실행되지 않습니다.** 단지 **함수 자체(함수 값)** 가 **`processUser`** 의 매개변수 **`callback`** 으로 전달됩니다.
2. **`processUser(greeting)`** 가 실행되면 **`greeting`** 함수는 **`callback`** 자리에 저장되어 있는 상태가 됩니다.
3. **`processUser`** 내부에서 **`const user = "HaYeong"`** 로 데이터를 준비해놓고,
4. **`callback(user)`** 를 실행하는 시점에 실제 **`greeting`** 함수가 실행됩니다.
5. 즉, **`callback(user)`** 은 **`greeting("HaYeong")`** 과 동일하게 동작하여 **`Hello, HaYeong`** 를 출력하게 됩니다.

#### ✏️ setTimeout() 콜백 함수

```js
// setTimeout() 콜백 함수를 활용한 예제
setTimeout(function () {
  console.log('3초 후 출력됩니다.');		// 출력: 3초 후 출력됩니다.
}, 3000);
```
- 지금 즉시 실행하는 함수가 아니라, **3초 후에 실행될 함수**를 **미리 전달**해두는 방식이기 때문에 콜백 함수입니다.

#### ✏️ 이벤트 핸들러

```js
// 버튼 클릭 이벤트에 콜백 함수 전달
const btn = document.createElement('button');
btn.textContent = '클릭하세요';
document.body.appendChild(btn);

btn.addEventListener('click', function() {
  console.log('버튼이 클릭되었습니다!');
});
```
- **`addEventListener`** 의 두 번째 인자 **익명 함수**가 바로 콜백 함수입니다.
- 사용자가 버튼을 클릭할 때만 실행되므로, **특정 시점에 호출**되는 콜백 함수의 특징을 잘 보여줍니다.



