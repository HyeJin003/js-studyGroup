# 객체와 변경불가성(Immutability)

const 는 변수 자체의 재할당을 막는 것이지, 변수에 저장된 값의 불변을 보장하지 않습니다.
객체의 내부 상태(프로퍼티)는 변경 가능합니다.

객체는 pass-by-reference 이기 때문에 주소를 참조하므로 복사본의 값을 바꿔버리면 원본 값도 변경됨. 예상하지 못한 값의 변화와 에러가 발생함.

그래서 위 문제를 해결하기 위한 3가지 방법이 있다.

1. 불변객체로 만듬.
2. 방어적 복사를 함.(defensive copy)
3. 관찰자 패턴 사용.(Observer 패턴)

---

Javascript의 원시 타입(primitive data type)은 변경 불가능한 값(immutable value)

- Boolean
- null
- undefined
- Number
- String
- Symbol (New in ECMAScript 6)  

원시 타입 이외의 모든 값은 객체(Object) 타입이며 객체 타입은 변경 가능한 값(mutable value)

## 불변 데이터 패턴(immutable data pattern)

### Object.assign
- 원본의 값이 훼손되지 않게 하기 위해서 방어적(한번 더 대비 함)으로 복사 하는 것.

```
Object.assign(target, ...sources) 복사를 함.

target - 어디로
sources - 출처
```
```
// Copy
const obj = { a: 1 }; // obj 객체 생성하고 그 안에 키:값은 a:1   
const copy = Object.assign({}, obj);  
// copy라는 변수 생성하고 Object.assign으로 방어적 복사를 하고 빈 객체를 생성하고 obj값을 빈 객체로 넣고 copy로 할당.
console.log(copy); // { a: 1 }  
console.log(obj == copy); // false(값은 똑같지만 주소가 다름)
```
```
// Merge
const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const merge1 = Object.assign(o1, o2, o3);
// o1인 target에 o2,o3 소스가 방어적 복사가 됨.

console.log(merge1); // { a: 1, b: 2, c: 3 } 
console.log(o1);     // { a: 1, b: 2, c: 3 }, 타겟 객체가 변경된다!
// 하지만 보통은 o1도 바뀌지 않는걸 원할때가 많음. 회사에선 싫어함.


// Merge
const o4 = { a: 1 };
const o5 = { b: 2 };
const o6 = { c: 3 };

const merge2 = Object.assign({}, o4, o5, o6);
// o4가 target이 되면 o4의 원본도 바뀌는걸 원하지 않는 경우가 많아서 {} 빈 객체를 target으로 만들어서 sources를 방어적 복사 한다.

console.log(merge2); // { a: 1, b: 2, c: 3 }
console.log(o4);     // { a: 1 }
```

**Shallow Copy (얕은 복사) vs  Deep Copy (깊은 복사)**
```
const user1 = {
  name: 'Lee',  // 1단계. 여기까지만 복사가 되는 게 얕은복사라고 함.
  address: {
    city: 'Seoul'  // 2단계. 여기까지 복사가 되는 것은 깊은복사라고 함.
  }
};

// 새로운 빈 객체에 user1을 copy한다.
const user2 = Object.assign({}, user1);
// user1과 user2는 참조값이 다르다.
console.log(user1 === user2); // false

user2.name = 'Kim';
console.log(user1.name); // Lee
console.log(user2.name); // Kim 
  // 정상적인 방어적 복사 확인 완료.


// 객체 내부의 객체(Nested Object - 중첩객체)는 Shallow copy된다.
console.log(user1.address === user2.address); // true
// address는 객체 안에 객체이므로 방어적 복사가 되지 않아 주소가 공유되어 true가 나옴.
// Object.assign은 얕은 복사를 함.

user1.address.city = 'Busan';
// 방어적 복사가 안된 상태에 원본을 수정하면 원본과 복사본 전부 수정됨.
console.log(user1.address.city); // Busan
console.log(user2.address.city); // Busan
```

### Object.freeze

Object.freeze()를 사용하여 불변(immutable) 객체로 만들수 있다.
```
const user1 = {
  name: 'Lee',
  address: {
    city: 'Seoul'
  }
};

// Object.assign은 완전한 deep copy를 지원하지 않는다.
const user2 = Object.assign({}, user1, {name: 'Kim'});

console.log(user1.name); // Lee
console.log(user2.name); // Kim

Object.freeze(user1); // user1을 불변객체로 바꿔버림.

user1.name = 'Kim'; // 무시된다!

console.log(user1); // { name: 'Lee', address: { city: 'Seoul' } }

console.log(Object.isFrozen(user1)); // true (얼었냐? 얼었다 그래서 true.)
```

- **Object.freeze도 얕은 복사처럼 동작함.**
- **deep freeze**를 만들어서 사용할 수 있다.(깊게 객체가 수정되지 않게 함.)
```
function deepFreeze(obj) {
  const props = Object.getOwnPropertyNames(obj);

  props.forEach((name) => {
    const prop = obj[name];
    if(typeof prop === 'object' && prop !== null) {
      deepFreeze(prop);
    }
  });
  return Object.freeze(obj);
}

const user = {
  name: 'Lee',
  address: {
    city: 'Seoul'
  }
};

deepFreeze(user); 
// deepFreeze를 위와 같이 만들어서 생성하면 아래의 결과처럼 중첩 객체의 내용들도 수정되지 않음.

user.name = 'Kim';           // 무시된다
user.address.city = 'Busan'; // 무시된다

console.log(user); // { name: 'Lee', address: { city: 'Seoul' } }
```

###  Immutable.js
- Object.assign과 Object.freeze을 사용하여 불변 객체를 만드는 방법은 번거러울 뿐더러 성능상 이슈가 있어서 큰 객체에는 사용하지 않는 것이 좋다.

- Facebook이 제공하는 Immutable.js를 사용하는 방법이 있다.

```
$ npm install immutable 설치 후 
```

Immutable.js의 Map 모듈을 임포트하여 사용함.

```
const { Map } = require('immutable')  // deepfreeze같이 사용 할 수 있다. 대신 npm 설치 후 require로 가져와서 사용해야 함.
const map1 = Map({ a: 1, b: 2, c: 3 }) // 위에 Map을 함수로 지정해서 require('immutable')를 넣어 주었기 때문에 require('immutable')를 사용하려면 Map을 써서 사용하면 됨.
const map2 = map1.set('b', 50)
map1.get('b') // 2
map2.get('b') // 50
```



