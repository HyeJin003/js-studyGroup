# 함수 (Function)

함수란?  
자주 사용하는 코드를 이름 붙여 저장하고 필요할 때 호출해서 재사용하는 것.

- 여러 번 호출 가능하며, 반복 작업을 효율적으로 수행.
- 객체 생성, 메서드 정의, 클로저, 모듈화 등 다양한 기능 수행.
- 자바스크립트 함수는 일급 객체로, 변수나 매개변수, 반환값으로 사용 가능.
- 다른 객체와의 차이점은 호출(call) 할 수 있다는 것.

## 함수 정의
1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수

**함수 선언문**

- `function` 키워드와 함수명으로 정의.
- 매개변수는 괄호 안에 쉼표로 구분.
  - 매개변수의 타입을 지정하지 않는게 다른 언어들과 차이점.(타입체크 필요)
- 중괄호로 문들을 감싸고 호출되었을 때 실행될 문들 작성.
- return으로 결과 반환.

```
function square(number) {
  return number * number;
}
```

**함수 표현식**

- `square 변수`에 할당할 함.(익명함수 가능)
- 함수 내부에서만 함수명을 참조 가능.
- 호출 시 변수명을 사용해야 함.

```
// 함수 표현식
var square = function(number) {
  return number * number;
};

console.log(square(5));
```

**Function 생성자 함수**

- 일반적으로 잘 사용하지 않음.
- Function 생성자 함수로 함수를 생성하는 문법
```
var square = new Function('number', 'return number * number');
console.log(square(10)); // 100
```
- Function 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다.
- 함수 선언문,함수 표현식은 함수 리터럴 방식으로 정의하는데 결국 내장 함수 Function 생성자 함수로 생성하는 것을 단순화시킨 short-hand(축약법).

## 함수 호이스팅

호이스팅이란?  
- var, function 선언문 등 선언문이 스코프의 최상단으로 끌어올려진 것처럼 동작하는 현상.

```
var res = square(5);

function square(number) {
  return number * number;
}
```

- 함수 선언문은 선언 위치와 상관없이 호출 가능.
  - 함수 선언, 초기화, 할당이 한번에 이루어지기 때문에 가능.
- 자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function, class)을 호이스팅(Hoisting)한다.

```
var res = square(5); // TypeError: square is not a function

var square = function(number) {
  return number * number;
}
```
- 함수 표현식은 변수 호이스팅만 일어남.선언 전에 호출 시 TypeError가 발생.
  - 스크립트 로딩 시점에 변수 객체에 함수를 할당하지 않고 runtime되기 때문.


- 함수를 선언 후 호출 하는 것을 권장함. 가독성과 성능에 좋다.
-   함수 선언문의 방식은 사용하기는 쉽지만 개발할 경우 너무 많은 변수객체를 저장 하므로 응답속도가 현저히 떨어질 수 있으므로 주의해야함.

## First-class object (일급 객체)

1. 무명의 리터럴로 표현이 가능.
2. 변수나 자료 구조(객체, 배열 등)에 저장.
3. 함수의 매개변수에 전달.
4. 반환값으로 사용.

- 위의 조건이 만족하므로 일급 객체라고 함.

## 매개변수(Parameter, 인자)
- 함수 실행에 필요한 데이터를 전달하는 변수.

**매개변수(parameter, 인자) vs 인수(argument)**
- 인수를 전달하지 않으면 매개변수는 undefined로 초기화
```
var foo = function (p1, p2) {
  console.log(p1, p2);
};

foo(1); // 1 undefined
```

**Call-by-value**
- 원시 타입은 값이 복사되어 전달됨 → 원본 변경 ❌
  - 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 원시 타입 값은 변경되지 않는다.
```
function foo(primitive) {
  primitive += 1;
  return primitive;
}

var x = 0;

console.log(foo(x)); // 1 값이 변경되지 않음.
console.log(x);      // 0 값이 변경됨.
```

**Call-by-reference**
- 객체 타입은 참조값이 전달됨 → 원본 변경 ⭕
```
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
  obj.gender = 'female';
}

var num = 100;
var obj = {
  name: 'Lee',
  gender: 'male'
};

console.log(num); // 100
console.log(obj); // Object {name: 'Lee', gender: 'male'}

changeVal(num, obj);

console.log(num); // 100
console.log(obj); // Object {name: 'Kim', gender: 'female'}
```


**원시 타입 인수** 
- 값을 복사하여 전달하기 때문에 매개변수에 전달하기 때문에 함수 몸체에 값을 변경하더라도 `side-effect가 없음`. `비순수 함수(Impure function)`

**객체형 인수**
- 객체형 인수는 참조값을 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경할 경우 원본 객체가 변경되는 `side-effect가 발생`. `순수함수(Pure function)`

** 부수 효과(side-effect) : 무언가를 바꾸었는데 원하지 않는 곳에서 따라서 변경이 이루어 지는 것.(무언가 수정 할 땐 잘 살펴 봐야함.)

## 반환값
- return으로 결과를 반환하고 함수 실행을 종료.
- 함수는 배열 등을 이용하여 한 번에 여러 개의 값을 리턴할 수 있다.
- 함수는 반환을 생략할 수 있다.(암묵적으로 undefined를 반환)
- 자바스크립트 해석기는 return을 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 이때 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다.

## 함수 객체의 프로퍼티
- 함수는 객체 이므로 프로퍼티를 가질 수 있다.
- 함수는 일반 객체와 다르게 함수만의 프로퍼티를 갖는다.

**arguments 프로퍼티**  
- 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 유사 배열 객체(array-like object)이며,함수 내부에서 지역변수처럼 사용된다.
    - 유사배열 객체 : length 프로퍼티를 가진 객체  
      배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용하여야 하는 번거로움이 있다.
- 인수를 전달하지 안아도 에러가 발생되지 않는다.
- 매개변수는 인수로 초기화 된다.
- 매개변수의 갯수보다 인수를 적게 전달했을 때 인수가 전달되지 않은 매개변수는 undefined으로 초기화된다.
- 매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다.
```
function multiply(x, y) {
  console.log(arguments);
  return x * y;
}

multiply();        // {}
multiply(1);       // { '0': 1 }
multiply(1, 2);    // { '0': 1, '1': 2 }
multiply(1, 2, 3); // { '0': 1, '1': 2, '2': 3 }
```
- 매개변수가 확정되지 않은 가변인자 함수를 구현 할때 유용하다.


**caller 프로퍼티**  
- 자신을 호출한 함수.

**length 프로퍼티**  
-  함수 정의 시 작성된 매개변수 갯수를 의미.

**name 프로퍼티**  
- 함수명을 나타낸다. 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다.

**__ proto __ 접근자 프로퍼티**  
- 모든 객체는 [[Prototype]]이라는 내부 슬롯이 있다.
- 객체로서 객체간의 상속(Inheritance)을 구현하기 위해 사용됨.
- __proto__ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다.
- 함수도 객체이므로 __proto__ 접근자 프로퍼티를 통해 프로토타입 객체에 접근할 수 있다.

**prototype 프로퍼티**  
- 함수 객체만이 소유하는 프로퍼티이다.
- 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체를 가리킨다.

## 함수의 다양한 형태
**즉시실행**
- 함수의 정의와 동시에 실행되는 함수
- 최초 한번만 호출되며 다시 호출할 수는 없고 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다.
- 문제점은 파일이 분리되어 있다하여도 글로벌 스코프가 하나이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능하다는 것.
  - 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 에러발생.
  - 변수명 또는 함수명의 충돌을 방지할 수 있어 이를 위한 목적으로 사용되기도 함.

**내부함수**
- 함수 내부에 정의된 함수
- 외부 함수의 변수에 접근 가능 (클로저 형태로 동작).

**재귀함수**
- 자기 자신을 호출하는 함수
- 자신을 무한히 연쇄 호출하므로 탈출 조건을 반드시 만들어야 한다.
  - 탈출 조건이 없는 경우, stackoverflow 에러가 발생.
- 대부분 for,while에 사용되는데 반복문 보단 직관적으로 이해하기 쉬운 구현이 가능한 경우에 사용하는 것이 바람직함.

**콜백함수**
- 이벤트 발생 또는 비동기 작업이 완료될 때 호출되는 함수.
- 비동기식 처리 모델에 사용되는데 처리가 종료되면 호출될 함수를 미리 매개변수에 전달하고 처리가 종료되면 콜백함수를 호출하는 것
- 콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다.

** 콜백 큐 : 자바스크립트의 비동기 작업이 완료된 뒤 실행될 함수들을 저장하는 공간  
** 클로저 : 함수가 자신이 선언될 때의 환경(스코프)을 기억하는 성질