# 12. 함수

## 함수?

어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드블록

이름과 매개변수를 가지며 필요할 때 호출하여 실행

## 1. 함수 정의

1. 함수 선언문
- `function` 키워드, **함수명**, **매개변수 목록**, **함수 몸체** 로 구성

```jsx
function square(number) {
  return number * number;
}
```

1. 함수 표현식
- 함수 리터럴 방식으로 함수를 정의하고 변수에 할당하는 방식
- 함수명 생략이 가능하고 이를 익명 함수라고 함
- 호출시 함수명이 아닌 변수명을 사용(함수 표현식에서 사용한 함수명은 외부 코드에서 접근 불가능)

```jsx
var square = function(number) {
  return number * number;
};
```

1. Function 생성자 함수
- Function.prototype.constructor 프로퍼티로 접근
- 일반적으로 사용X(가독성,성능, 보안)
- 동적으로 코드를 만들어야 하는 경우

```jsx
var square = new Function('number', 'return number * number');
console.log(square(10)); // 100
```

## 2. 함수 호이스팅

함수 선언의 위치와는 상관없이 코드 내 어디서든 호출이 가능한 것

- 함수 선언문- 선언, 초기화, 할당이 한번에 이루어져 위치와는 상관없이 호출 가능
- 함수 표현식- 변수 호이스팅이 발생하며 변수 생성 및 초기화, 할당이 분리 됨

## 3. 일급 객체

프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상

**조건 만족시**

1. 무명의 리터럴로 표현이 가능하다.
2. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 반환값으로 사용할 수 있다.

## 4. 매개변수

함수 실행을 위해 필요할 경우 지정하며 함수 내에서 변수와 동일하게 동작

인수를 전달하지 않으면 undefined로 초기화

**Call-by-value**

- 함수 호출 시 원시 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식
- 매개변수를 통해 값이 변경되어도 전달된 원시 타입 값은 변경X

```jsx
function foo(primitive) {
  primitive += 1;
  return primitive;
}

var x = 0;

console.log(foo(x)); // 1
console.log(x);      // 0
```

**Call-by-reference**

- 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식
- 참조값으로 객체의 값을 변경했을 때 전달된 참조형의 인수값도 같이 변경

```jsx
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
  obj.gender = 'female';
}

var num = 100;
var obj = {
  name: 'Lee',
  gender: 'male'
};

console.log(num); // 100
console.log(obj); // Object {name: 'Lee', gender: 'male'}

changeVal(num, obj);

console.log(num); // 100
console.log(obj); // Object {name: 'Kim', gender: 'female'}
```

## 5. 반환값

함수는 자신을 호출한 코드에게 수행한 결과를 반환할 수 있다.

- `return` 키워드는 함수를 호출한 코드에게 값을 반환할 때 사용
- 함수는 배열 등을 이용하여 한 번에 여러 개의 값을 리턴할 수 있다.
- 함수 반환을 생략 → 암묵적으로 undefined를 반환
- 자바스크립트 해석기는 `return` 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 `return` 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다.

## 6. 함수 객체의 프로퍼티

### argumenets

arguments 객체는 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다

```jsx
function multiply(x, y) {
  console.log(arguments);
  return x * y;
}

multiply();        // {}
multiply(1);       // { '0': 1 }
multiply(1, 2);    // { '0': 1, '1': 2 }
multiply(1, 2, 3); // { '0': 1, '1': 2, '2': 3 }
```

- 매개변수 갯수보다 인수를 적게 전달하면 적게 전달된 변수는 `undefined`
- 더 많은 인수를 전달한 경우 초과된 인수는 무시

→매개변수가 확정되지 않은 가변 인자 함수를 구현할 때 유용

### caller

자신을 호출한 함수

```jsx
function foo(func) {
  var res = func();
  return res;
}

function bar() {
  return 'caller : ' + bar.caller;
}

console.log(foo(bar)); // caller : function foo(func) {...}
console.log(bar());    // null (browser에서의 실행 결과)
```

### length 

함수 정의 시 작성된 매개변수 갯수

### name

함수명을 나타내며 익명함수의 경우 빈문자열을 가짐

### __proto__

prototype객체에 접근하기 위한 프로퍼티로 상속 구조를 확인하거나 수정할 떄 사용

### prototype

함수 객체만이 소유하는 프로퍼티

일반 객체는 prototype 프로퍼티를 소유하지 않음

```jsx
// 함수 객체는 prototype 프로퍼티를 소유한다.
console.log(Object.getOwnPropertyDescriptor(function() {}, 'prototype'));
// {value: {…}, writable: true, enumerable: false, configurable: false}

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
console.log(Object.getOwnPropertyDescriptor({}, 'prototype'));
// undefine
```

- 생성자 함수가 가지고 있는 프로퍼티로  만든 모든 인스턴스를 공유한다

## 7. 함수의 다양한 형태

### 즉시 실행 함수

함수의 정의와 함께 실행
- 최초 한번만 호출되어 다시 호출X
- 즉시 실행 함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지할 수 있어 이를 위한 목적으로 즉시실행함수를 사용되기도 한다.

```jsx
// 기명 즉시 실행 함수(named immediately-invoked function expression)
(function myFunction() {
  var a = 3;
  var b = 5;
  return a * b;
}());

// 익명 즉시 실행 함수(immediately-invoked function expression)
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

// SyntaxError: Unexpected token (
// 함수선언문은 자바스크립트 엔진에 의해 함수 몸체를 닫는 중괄호 뒤에 ;가 자동 추가된다.
function () {
  // ...
}(); // => };();

// 따라서 즉시 실행 함수는 소괄호로 감싸준다.
(function () {
  // ...
}());

(function () {
  // ...
})();
```

### 내부 함수

함수 내부에 정의된 함수

- 내부함수는 부모함수의 변수에 접근 가능/ 부모함수의 외부에서는 X
- 부모함수는 내부함수에 접근X

```jsx
function parent(param) {
  var parentVar = param;
  function child() {
    var childVar = 'lee';
    console.log(parentVar + ' ' + childVar); // Hello lee
  }
  child();
  console.log(parentVar + ' ' + childVar);
  // Uncaught ReferenceError: childVar is not defined
}
parent('Hello')
```

### 재귀 함수

자기 자신을 호출하는 함수

- 자신을 무한히 연쇄 호출하므로 탈출 조건을 만들어야 한다

```jsx
// 피보나치 수열
// 피보나치 수는 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다.
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...
function fibonacci(n) {
  if (n < 2) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(0)); // 0
console.log(fibonacci(1)); // 1
console.log(fibonacci(2)); // 1
console.log(fibonacci(3)); // 2
console.log(fibonacci(4)); // 3
console.log(fibonacci(5)); // 5
console.log(fibonacci(6)); // 8
```

### 콜백 함수

특정 이벤트가 발생했을 떄 시스템에 의해 호출되는 함수

```jsx
<!DOCTYPE html>
<html>
<body>
  <button id="myButton">Click me</button>
  <script>
    var button = document.getElementById('myButton');
    button.addEventListener('click', function() {
      console.log('button clicked!');
    });
  </script>
</body>
</html>
```

- ex. mybutton 클릭 시  button clicked!를 출력
